디퍼드 쉐이더란? 후처리 쉐이더
--> 렌더링 이후에 처리를 하겠다.

내가 필요한 정보를 렌더타겟에 저장해두고, 렌더링 이후에 렌더타겟을 이용해 처리한다.
렌더 타겟 : '그려놓은 장면, 그려놓을 수 있는 장면' (ex. 백버퍼)

IDirect3DSurface9 : 렌더 타겟 객체 생성 --> 이게 곧 텍스쳐다.
1. 텍스쳐를 생성
2. 텍스쳐에서 GetSurface 어쩌고 해서 텍스쳐를 받아올 수 있다.
텍스쳐를 만들어서 렌더타겟을 하나 뽑아내보자




다렉 장치는 4개의 렌더 타겟을 가질 수 있다. (1개는 백버퍼)

렌더타겟을 추가적으로 생성한다.
- 처음
0번 : 백버퍼 ( Skybox ... )

- 백버퍼 그린 이후
0번 : Diffuse (픽셀들이 빛을 어떻게 반사 해야 할까?), 텍스쳐 Color
1번 : Normal (Normal 벡터를 저장하기 위한 타깃), 명암연산

PS_OUT구조체의 
COLOR0 시멘틱 --> 몇번째 렌더타겟에 그릴건지? COLOR0 , COLOR1 ...

PS_OUT{
	vColor : COLOR0
	vNormal : COLOR1 --> VS_OUT에서 뱉어준 Normal을 그대로 받아 넣는다.
}

- Diffuse / Normal 이후 ( 지형 ,플레이어, 오브젝트 등은 이미 렌더 호출이 끝난 상태이다.)
0번 : Shade ( 명암을 그리기 위한 타깃, 디퍼드 쉐이딩 ) --> 모든 픽셀을 채워야 한다. --> RHW버퍼를 써야 윈도우사이즈를 받는다.
화면에 꽉 차는 XYZ RHW (렌더링 파이프라인을 모두 거친 뒤의 버퍼)

버퍼를 그리기 위한 쉐이더를 만든다.
[ 빛정보와 Normal이 필요하다. , Normal은 이전에 만들어둔 Normal 타깃의 텍스쳐를 전역변수로 넘겨줄 것이다.]

- Shade 이후
0번 : 백버퍼

새로운 RHW 버퍼
Diffuse와 Shade타깃을 가져와서 두 텍스쳐를 곱한다. --> 진짜 색 * 빛

------------------------
장면에 들어오는 객체들만 명암연산을 할 수 있다. 
쉐이더 연산(명암연산)이 객체 갯수에 영향을 받지 않는다. --> 화면에 그려진 픽셀 갯수만큼만 연산한다.

