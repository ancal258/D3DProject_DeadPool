두번쨰 텍스쳐는 그냥 노말을 저장
메쉬그리는 쉐이더에 NormalTexture를 전역변수로 전달을 한다.
(필터링 하지 말고 그냥 얻어오자.)

Tex2D로 현재 픽셀의 vector를 얻어온다.
(실제 타겟은 0~1까지 밖에 못갖기 때문에, 노말 맵 또한 0~1사이로 이미 보간 해놓은 값이다.)
--> 다시 원래 -1~1 값으로 바꿔줘야 한다.

이렇게 가져온 Normal을 Normal타겟에 저장해주면 빛 연산은 끝난다.

---------------------------------------------------------
x y z 노말을 가져왔지만 그대로 사용할 수 없다. 
펴놓으면 거의 90도 짜리 들이기 때문에

노말 픽셀들은 로컬스페이스가 아니라 실제 존재하는 3차원 좌표계 스페이스에 존제한다.
'접선공간'(탄젠트 스페이스) 
정점의 Normal이 tan스페이스 정점의 Look 벡터가 된다.

이걸 이용해 월드스페이스로 옮기면 된다.

직교한 기저벡터 3개 (좌표계)를 월드스페이스로 변환해주는 작업만 하면 된다.
--> 월드행렬만 곱해주면 된닷! 
--> 이러면 월드공간상에 있는 3개의 벡터가 만들어진다. (정점의 노멀을 월드공간으로 옮긴것.)
--> 그렇게 구한 Right Up Look 벡터로 행렬을 만들어준다.
--> 그 행렬이 tan스페이스 녀석을 내 게임의 world로 바꾸기 위한 행렬이다.
(텍스쳐의 Normal을 월드로 보내는 과정)

( 우리는 Look 벡터밖에 없다. )
면을 수평으로 지나가는 접선인 벡터를 구해야한다. 
(DX9 함수중에 이 벡터를 구하는 함수를 제공하고 있다. --> D3DXCompute탄젠트)

정점에 탄젠트를 저장할 수 있는 공간을 확보해 줘야한다.

D3DXCloneMeshFVF 함수 할 때 FVF 넣어주는데, 거기서 tan를 넣어서 추가하면 된다?
(D3D에서 tanFVF가 없어서 문제 ㅡㅡ)

D3DCloneMesh 를 이용하면 된다 .

D3DElement9 : 정점의 FVF 하나를 저장하기 위한 구조체. 
--> 배열로 선언해주고 탄젠트가 포함된 상태로 위 함수의 인자로 전달해주면 끝난다.
Declare 탄젠트 뭐 추가하면 된다.

---> 이러고 뭐 다 추가하고 D3DXComputeTan 하면 끝난다;
탄젠트 시멘틱은 D3D 디클래어 유지에이지에 다 있다.
VS_IN에 그 탄젠트를 넘겨주고 계산해주면 된다.

float3 * float3 ? 

월드행렬 곱해놓은 라업룩 벡터 (VS) --> Normalize해줘야된다 ( 스케일 값 들어감 )
VS_OUT으로 보내
픽셀쉐이더에서 3 * 3 행렬 만들고
vNormal을 곱하자.
----> 또 타겟에 저장할 땐 0~1로 바꿔서 저장해야한다.

--------------------------------------------------------스태틱메쉬...

UpdateSkinedMesh : 메시컨테이너 안에 저장되어있는 스킨객체로부터 호출했던 함수
내가 렌더링해야하는 뼈의 행렬 정보대로 정점들을 바꿔주는 과정


탄젠트가 추가되어있지 않은 구조체에서 행렬정보를 곱해주는 과정에서 고장난다.
SkinInfo에 Set_디클레이션 --> 인자로 아까 만들었던 배열 구조체를 갱신해주면 애니메이션메쉬에도 잘 먹어서 동작할것이다.
